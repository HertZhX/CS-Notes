# 算法 - 栈和队列
<!-- GFM-TOC -->
* [算法 - 栈和队列](#算法---栈和队列)
    * [栈](#栈)
        * [1. 数组实现](#1-数组实现)
        * [2. 链表实现](#2-链表实现)
    * [队列](#队列)
<!-- GFM-TOC -->


## 栈

```cpp
template <typename Item>
class MyStack {
public:
    virtual ~MyStack() = default;
    virtual MyStack<Item>& push(Item item) = 0;
    virtual Item pop() = 0;
    virtual bool isEmpty() const = 0;
    virtual int size() const = 0;
};
```

### 1. 数组实现

```cpp
template <typename Item>
class ArrayStack : public MyStack<Item> {
private:
    // 使用vector作为动态数组
    std::vector<Item> data;

public:
    ArrayStack() {
        // 初始大小设为1
        data.reserve(1);
    }

    ~ArrayStack() override = default;

    MyStack<Item>& push(Item item) override {
        checkCapacity();
        data.push_back(item);
        return *this;
    }

    Item pop() override {
        if (isEmpty()) {
            throw std::runtime_error("stack is empty");
        }

        Item item = data.back();
        data.pop_back();
        checkShrink();
        return item;
    }

    bool isEmpty() const override {
        return data.empty();
    }

    int size() const override {
        return data.size();
    }

private:
    // 检查是否需要扩容
    void checkCapacity() {
        if (data.size() >= data.capacity()) {
            data.reserve(data.capacity() * 2);
        }
    }

    // 检查是否需要缩容
    void checkShrink() {
        // 当元素数量小于容量的1/4时，缩容为原来的1/2
        if (data.size() > 0 && data.size() <= data.capacity() / 4) {
            data.shrink_to_fit();
            // 或者更精确地控制容量
            // std::vector<Item> temp(data);
            // data.swap(temp);
        }
    }
};
```

### 2. 链表实现

需要使用链表的头插法来实现，因为头插法中最后压入栈的元素在链表的开头，它的 next 指针指向前一个压入栈的元素，在弹出元素时就可以通过 next 指针遍历到前一个压入栈的元素从而让这个元素成为新的栈顶元素。

```cpp
template <typename Item>
class ListStack : public MyStack<Item> {
private:
    // 链表节点定义
    struct Node {
        Item item;
        Node* next;
        
        explicit Node(Item value)
            : item(std::move(value)), next(nullptr) {}
    };

    Node* topNode; // 栈顶指针
    int count;     // 元素数量

public:
    ListStack() : topNode(nullptr), count(0) {}

    ~ListStack() override {
        // 析构函数释放所有节点内存
        while (!isEmpty()) {
            pop();
        }
    }

    MyStack<Item>& push(Item item) override {
        // 创建新节点并设为栈顶
        Node* newNode = new Node(std::move(item));
        newNode->next = topNode;
        topNode = newNode;
        count++;
        return *this;
    }

    Item pop() override {
        if (isEmpty()) {
            throw std::runtime_error("stack is empty");
        }

        // 保存当前栈顶元素
        Node* temp = topNode;
        Item item = std::move(temp->item);
        
        // 更新栈顶指针并释放内存
        topNode = topNode->next;
        delete temp;
        count--;
        
        return item;
    }

    bool isEmpty() const override {
        return count == 0;
    }

    int size() const override {
        return count;
    }
};
```

## 队列

下面是队列的链表实现，需要维护 first 和 last 节点指针，分别指向队首和队尾。

这里需要考虑 first 和 last 指针哪个作为链表的开头。因为出队列操作需要让队首元素的下一个元素成为队首，所以需要容易获取下一个元素，而链表的头部节点的 next 指针指向下一个元素，因此可以让 first 指针指向链表的开头。

```cpp
template <typename Item>
class MyQueue {
public:
    virtual ~MyQueue() = default;
    virtual MyQueue<Item>& add(Item item) = 0;
    virtual Item remove() = 0;
    virtual bool isEmpty() const = 0;
    virtual int size() const = 0;
};
```

```cpp
template <typename Item>
class ListQueue : public MyQueue<Item> {
private:
    // 链表节点定义
    struct Node {
        Item item;
        Node* next;
        
        explicit Node(Item value)
            : item(std::move(value)), next(nullptr) {}
    };

    Node* first; // 指向队首
    Node* last;  // 指向队尾
    int count;   // 元素数量

public:
    ListQueue() : first(nullptr), last(nullptr), count(0) {}

    ~ListQueue() override {
        // 析构函数释放所有节点内存
        while (!isEmpty()) {
            remove();
        }
    }

    MyQueue<Item>& add(Item item) override {
        // 创建新节点
        Node* newNode = new Node(std::move(item));
        
        if (isEmpty()) {
            // 队列为空时，新节点既是队首也是队尾
            first = newNode;
            last = newNode;
        } else {
            // 队列不为空时，将新节点添加到队尾
            last->next = newNode;
            last = newNode;
        }
        
        count++;
        return *this;
    }

    Item remove() override {
        if (isEmpty()) {
            throw std::runtime_error("queue is empty");
        }
        
        // 保存队首元素
        Node* temp = first;
        Item item = std::move(temp->item);
        
        // 更新队首指针
        first = first->next;
        delete temp;
        count--;
        
        // 如果队列为空，将队尾指针也设为nullptr
        if (isEmpty()) {
            last = nullptr;
        }
        
        return item;
    }

    bool isEmpty() const override {
        return count == 0;
    }

    int size() const override {
        return count;
    }
};
```
