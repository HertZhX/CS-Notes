<!-- GFM-TOC -->
* [this 指针基础](#this-指针基础)
<!-- GFM-TOC -->


## 1 `this` 指针的基础

在 C++ 的面向对象编程中，`this` 指针是编译器隐式提供的一个特殊的指针，它指向调用成员函数的那个对象。在非静态成员函数内部，你可以使用 `this` 指针访问调用对象的成员。

### 1.1 `this`  指针的定义和基本理解

在 C++ 中，`this` 是一个指向当前对象的指针，我们可以通过 `this` 来访问当前对象的所有成员。`this` 实际上是当前类类型的指针，例如，对于类 `Box` 的成员函数，`this` 是 `Box*` 类型的指针。

```cpp
class Box {    
	int length;  // 定义私有的整型变量 length
public:    
	void setLength(int length) {        
		this->length = length;  // 将传入的整数值赋给当前对象的 length 成员变量    
	}
};
```

（2）`this` **指针在成员函数中的使用，以及如何通过** `this` **访问成员变量和成员函数**

`this` 指针可以在类的所有非静态成员函数中使用，包括构造函数和析构函数。我们可以使用 `this` 指针来访问成员变量和成员函数。

```
std::cout << "Length: " << this->getLength() << std::endl;
```

在上述代码中，我们在 `setLength` 函数中使用 `this` 指针访问了成员变量 `length`。在 `display` 函数中，我们通过 `this` 指针调用了 `getLength` 成员函数。

记住，只有在成员函数内部，我们才能使用 `this` 指针，因为只有在这个时候，`this` 指针才有被调用的对象实例来指向。

## 3 `this` 指针在实际编程中的应用

`this` 指针在编程实践中有着广泛的应用，它可以帮助我们解决变量命名冲突，实现链式调用，并在拷贝构造函数和赋值操作符中起到关键的作用。

#### **（1）解决变量命名冲突**

在类的成员函数中，如果形参名称与类的成员变量名称相同，可以使用 `this` 指针消除歧义。

```
void setLength(int length) {
```

在这个示例中，`this` 指针用于解决 `length` 形参与 `length` 成员变量之间的命名冲突。

#### **（2）链式调用**

链式调用是一种编程技巧，可以使代码更加紧凑和易读。它通过在每个成员函数中返回 `*this`，使得多个成员函数调用可以在同一行内连续进行。

```
Box& setLength(int length) {  


Box& setWidth(int width) {  


        std::cout << "Length: " << length << ", Width: " << width << std::endl;  


b.setLength(10).setWidth(5).display();
```

#### **（3）拷贝构造函数和赋值操作符**

`this` 指针在拷贝构造函数和赋值操作符中也扮演着重要的角色。在这些函数中，我们通常需要检查传入的对象是否就是当前对象（即，是否是自我赋值）。如果是，则应避免进行可能导致错误的自我赋值。

```
Box& operator=(const Box& other) {


            std::copy(other.data, other.data + 10, data);
```

在这个例子中，我们首先检查 `this` 是否等于 `&other`，如果等于，则说明这是自我赋值，我们应避免执行可能破坏对象状态的操作。这是 `this` 指针在拷贝构造函数和赋值操作符中的常见用法。

## 4 `this` 指针在继承和多态中的作用

在 C++ 中，`this` 指针在处理继承和多态问题时起到了非常重要的作用。它在动态绑定，虚函数和覆盖等方面发挥着重要作用。

#### **（1）通过** `**this**` **指针实现动态绑定**

动态绑定是多态的关键机制之一，它使得在运行时可以根据对象的实际类型来调用相应的成员函数。`this` 指针在这个过程中起到了关键的作用。

```
virtual void print() const { 


        std::cout << "Base::print()" << std::endl;


class Derived : public Base {  


void print() const override { 


        std::cout << "Derived::print()" << std::endl;


void callPrint(const Base* base) {
```

在上述代码中，我们有一个基类 `Base` 和一个派生类 `Derived`，它们都有一个 `print` 成员函数。在 `callPrint` 函数中，我们通过 `this` 指针（`base`）来调用 `print` 函数，此时会发生动态绑定。

#### **（2）**`**this**` **指针在虚函数和覆盖中的行为**

在虚函数和覆盖中，`this` 指针指向的是最初用来调用成员函数的那个对象。如果我们在派生类中覆盖了基类的虚函数，那么 `this` 指针的类型在这个虚函数中仍然是基类的指针类型，但它实际上指向的是派生类的对象。

```
virtual void print() const {  


        std::cout << "This is a Base object." << std::endl;


class Derived : public Base {


void print() const override {  


        std::cout << "This is a Derived object." << std::endl;
```

在这个例子中，当我们通过派生类对象 `d` 调用 `print` 函数时，`this` 指针指向的是 `d` 对象。在 `Derived::print` 函数中，我们首先调用了基类的 `print` 函数，然后再输出一行信息。这说明即使在覆盖了基类虚函数的派生类中，`this` 指针仍然能够正确地指向派生类的对象。

## 5 `this` 指针与 `const` 成员函数

在 C++ 中，`this` 指针在 `const` 成员函数中的行为有一些特殊之处。这部分内容，我们将详细探讨 `this` 指针在 `const` 成员函数中的类型和意义，以及如何使用 `const` 成员函数来保证对象状态的不变性。

#### **（1）**`**const**` **成员函数中** `**this**` **指针的类型和意义**

在 `const` 成员函数中，`this` 指针的类型是指向 `const` 类型的指针。这意味着你不能通过 `this` 指针修改对象的状态。

  

在这个例子中，`getLength` 是一个 `const` 成员函数。在这个函数中，`this` 指针的类型是 `const Box*`，所以你不能通过 `this` 指针来修改 `length`。

  

#### **（2）使用** `**const**` **成员函数保证对象状态的不变性**

  

`const` 成员函数是一种保证对象状态不变性的重要机制。当你将一个成员函数声明为 `const`，你就是在承诺这个函数不会修改对象的状态。这对于编写稳定可靠的代码非常有用。

  

```
Box(int length) : length(length) {}  


void increaseLength(int increment) {
```

在这个示例中，`increaseLength` 是一个非 `const` 成员函数，它可以修改对象的状态。而 `getLength` 是一个 `const` 成员函数，它不能修改对象的状态。当你需要读取对象的状态，但不想修改它时，你应该使用 `const` 成员函数。

## 6 `this` 指针在多线程编程中的使用

多线程编程是现代计算中的一个重要部分，它允许在一个程序中同时执行多个任务。在这个环境中，`this` 指针的行为和使用有一些特殊之处，特别是在处理多线程同步和数据竞争的问题时。

#### **（1）**`**this**` **指针在多线程环境中的行为**

在多线程环境中，每个线程都有其独立的栈空间，因此在每个线程中，`this` 指针的值是独立的。也就是说，`this` 指针只能在同一线程中传递，而不能跨线程传递。

假设我们有一个类 `Box`，并且我们在两个不同的线程中同时创建了 `Box` 对象，那么在每个线程中，`this` 指针都会指向其各自创建的 `Box` 对象。

#### **（2）使用** `**this**` **指针处理多线程同步和数据竞争**

在多线程编程中，`this` 指针常常用于处理多线程同步和数据竞争的问题。例如，我们可能需要在一个类的成员函数中使用 `this` 指针来获取一个互斥锁，以保护类的数据成员不受并发访问的影响。

```
void setData(int value) {


std::lock_guard<std::mutex> lock(mtx);  


void threadFunction(Box* box, int value) {


std::thread t1(threadFunction, &b, 10);  


std::thread t2(threadFunction, &b, 20);
```

在这个例子中，`setData` 成员函数使用 `this` 指针来获取一个互斥锁，以保护 `data` 成员变量。当我们在两个线程中同时调用 `setData` 函数时，由于互斥锁的存在，只有一个线程可以访问 `data` 成员变量，这就避免了数据竞争的问题。

## 7 `this` 指针的注意事项和常见陷阱

尽管 `this` 指针是一个强大的工具，但是在使用它的过程中也需要注意一些陷阱和限制，尤其是在构造函数、析构函数以及返回将要析构对象的 `this` 指针等方面。

#### **（1）**`**this**` **指针在构造函数和析构函数中的使用限制**

在构造函数和析构函数中使用 `this` 指针需要特别小心。在构造函数中，由于对象还没有完全构造完成，因此使用 `this` 指针访问未初始化的成员变量可能会导致未定义的行为。同样，在析构函数中，如果对象已经部分或完全析构，那么使用 `this` 指针可能会导致问题。

  

#### **（2）避免返回将要析构对象的** `**this**` **指针**

  

一个常见的陷阱是在一个成员函数中返回 `this` 指针，尤其是当这个成员函数是一个临时对象的成员函数时。在函数返回后，临时对象会被析构，此时返回的 `this` 指针就会变成悬垂指针，这会导致未定义的行为。

  

```
Box(int value) : data(value) {}


return Box(10).getDataPtr();
```

在上述代码中，`badFunc` 函数返回的是一个将要被析构的临时对象的 `this` 指针，这会导致 `p` 成为一个悬垂指针。为了避免这种情况，我们应该尽量避免在成员函数中返回 `this` 指针，或者确保返回的 `this` 指针指向的对象在函数返回后仍然存在。

## 8 总结：

本文深入探讨了在 C++ 中的 `this` 指针的重要性和应用。以下是对 `this` 指针的关键知识点和使用技巧的回顾，以及对 `this` 指针在 C++ 编程中的价值的评价。

- `this` 指针是一个指向当前对象的特殊指针。在非静态成员函数内部，可以使用 `this` 指针来访问调用对象的成员。
- `this` 指针在成员函数中的使用非常灵活，可以通过 `this->member` 来访问成员变量，或者通过 `this->function()` 来调用成员函数。
- 在解决变量命名冲突时，`this` 指针可以帮助消除歧义，使代码更清晰易懂。
- `this` 指针在链式调用中扮演重要角色，通过返回 `*this`，可以实现在同一行内连续调用多个成员函数。
- 在拷贝构造函数和赋值操作符中，`this` 指针用于处理自我赋值的情况，避免可能导致错误的操作。
- 在继承和多态中，`this` 指针能够实现动态绑定，确保调用正确的函数实现。
- 在虚函数和覆盖中，`this` 指针在虚函数调用时保持准确，指向的是最初用来调用成员函数的对象。
- 在 `const` 成员函数中，`this` 指针的类型变为 `const T*`，用于保证对象状态的不变性。
- 在多线程环境中，每个线程都有独立的 `this` 指针，因此无法跨线程传递 `this` 指针。在多线程编程中，`this` 指针常用于处理多线程同步和数据竞争问题。
- 在构造函数和析构函数中，对 `this` 指针的使用有限制。在构造函数中，`this` 指针不能用于访问未初始化的成员变量；在析构函数中，使用 `this` 指针可能导致未定义的行为。
- 避免在成员函数中返回将要析构的对象的 `this` 指针，以避免悬垂指针的问题。

**总体评价：**

`this` 指针是 C++ 中一项强大的特性，它为我们提供了访问当前对象的能力，并在多种编程场景中发挥重要作用。通过正确理解和使用 `this` 指针，我们可以编写出更清晰、更有效的代码。

---

来自: [【C++】C++中的 `this` 指针：深度探索和应用_c++ this-CSDN博客](https://blog.csdn.net/crr411422/article/details/131063469)


